// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Pg = require("pg");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Promise = require("@rescript/core/src/Core__Promise.res.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var Uuid = {};

var Spacetime = {};

var GraphileLogger = {};

var FieldInfo = {};

var PgResult = {
  FieldInfo: FieldInfo
};

function $$catch(promise) {
  return Core__Promise.$$catch(promise, (function (e) {
                console.error("Caught unexpected error in NodePostgres", e);
                return Promise.reject(e);
              }));
}

function toObject(e) {
  return {
          message: e.message,
          code: e.code,
          name: e.name,
          stack: e.stack
        };
}

var PgError = {
  $$catch: $$catch,
  toObject: toObject
};

function query(initator, statement, params, cb) {
  return initator.query(statement, params, (function (error, res) {
                if (error !== undefined) {
                  return cb({
                              TAG: "Error",
                              _0: error
                            });
                } else if (res !== undefined) {
                  return cb({
                              TAG: "Ok",
                              _0: res
                            });
                } else {
                  return Js_exn.raiseTypeError("Invalid callback in nodePg query");
                }
              }));
}

var QueryCallback = {
  query: query
};

function $$int($$int$1) {
  return $$int$1;
}

function string(string$1) {
  return string$1;
}

function uuid(uuid$1) {
  return uuid$1;
}

function spacetime(date) {
  return date.format("iso");
}

function array(array$1) {
  return array$1;
}

function intArray(array) {
  return array;
}

function stringArray(array) {
  return array;
}

function option(option$1) {
  return option$1;
}

function json(json$1) {
  return JSON.stringify(json$1);
}

function dict(dict$1) {
  return dict$1;
}

function obj(obj$1) {
  return obj$1;
}

function interval(quantity, unit) {
  var q = quantity.toString();
  var s = quantity !== 1 ? "s" : "";
  return q + " " + unit + s;
}

var $$null = null;

function nullable(param) {
  if (param !== undefined) {
    return Caml_option.valFromOption(param);
  } else {
    return $$null;
  }
}

function query$1(rowMode, initiator, statement, params) {
  return initiator.query({
              text: statement,
              values: params,
              rowMode: rowMode
            });
}

var Params = {
  $$int: $$int,
  string: string,
  uuid: uuid,
  spacetime: spacetime,
  intArray: intArray,
  stringArray: stringArray,
  array: array,
  option: option,
  json: json,
  dict: dict,
  obj: obj,
  interval: interval,
  $$null: $$null,
  nullable: nullable,
  query: query$1
};

function getFirst(res) {
  return res.then(function (param) {
              return param.rows[0];
            });
}

function getUnique(res, logger, itemId, itemName) {
  return Core__Promise.$$catch(getFirst(res), (function (e) {
                logger.error("error while retrieving " + itemName + " with ID " + itemId, e);
                return Promise.reject(e);
              }));
}

var PgNotFound = /* @__PURE__ */Caml_exceptions.create("PgBind.Query.PgNotFound");

function getUniqueExn(res, logger, itemId, itemName) {
  return getUnique(res, logger, itemId, itemName).then(function (item) {
              if (item !== undefined) {
                return Promise.resolve(Caml_option.valFromOption(item));
              } else {
                logger.error("no " + itemName + " with ID " + itemId, Js_exn.raiseError("Not found"));
                return Promise.reject({
                            RE_EXN_ID: PgNotFound,
                            name: itemName,
                            id: itemId
                          });
              }
            });
}

function getFirstValueExn(res, logger, valueName) {
  return Core__Promise.$$catch(getFirst(res), (function (e) {
                  logger.error("error while retrieving " + valueName, e);
                  return Promise.reject(e);
                })).then(function (item) {
              if (item !== undefined) {
                var match = Js_dict.values(item);
                if (match.length !== 1) {
                  logger.error("Result is supposed to have only one field to get " + valueName + ", got ", Js_exn.raiseError(Object.keys(item).join(", ")));
                  return Promise.reject({
                              RE_EXN_ID: PgNotFound,
                              name: valueName,
                              id: undefined
                            });
                } else {
                  return Promise.resolve(match[0]);
                }
              }
              logger.error("Got no result when looking for " + valueName, Js_exn.raiseError("Not found"));
              return Promise.reject({
                          RE_EXN_ID: PgNotFound,
                          name: valueName,
                          id: undefined
                        });
            });
}

function getFirstValue(res, logger, valueName) {
  return Core__Promise.$$catch(getFirst(res), (function (e) {
                  logger.error("error while retrieving " + valueName, e);
                  return Promise.reject(e);
                })).then(function (item) {
              if (item === undefined) {
                return Promise.resolve(undefined);
              }
              var match = Js_dict.values(item);
              if (match.length !== 1) {
                logger.error("Result is supposed to have only one field to get " + valueName + ", got ", Js_exn.raiseError(Object.keys(item).join(", ")));
                return Promise.reject({
                            RE_EXN_ID: PgNotFound,
                            name: valueName,
                            id: undefined
                          });
              }
              var value = match[0];
              return Promise.resolve(Caml_option.some(value));
            });
}

function query$2(initator, statement, params) {
  return $$catch(initator.query(statement, params).then(function (res) {
                  return {
                          TAG: "Ok",
                          _0: res
                        };
                }));
}

var Res = {
  query: query$2
};

var Query = {
  Params: Params,
  getFirst: getFirst,
  getUnique: getUnique,
  PgNotFound: PgNotFound,
  getUniqueExn: getUniqueExn,
  getFirstValueExn: getFirstValueExn,
  getFirstValue: getFirstValue,
  Res: Res
};

var Builtins = {};

var TypeOverrides = {
  Builtins: Builtins
};

function make(user, password, host, database, port, connectionString, ssl, types, statement_timeout, query_timeout, application_name, connectionTimeoutMillis, idle_in_transaction_session_timeout, param) {
  var tmp = {};
  if (user !== undefined) {
    tmp.user = user;
  }
  if (password !== undefined) {
    tmp.password = password;
  }
  if (host !== undefined) {
    tmp.host = host;
  }
  if (database !== undefined) {
    tmp.database = database;
  }
  if (port !== undefined) {
    tmp.port = port;
  }
  if (connectionString !== undefined) {
    tmp.connectionString = connectionString;
  }
  if (ssl !== undefined) {
    tmp.ssl = Caml_option.valFromOption(ssl);
  }
  if (types !== undefined) {
    tmp.types = Caml_option.valFromOption(types);
  }
  if (statement_timeout !== undefined) {
    tmp.statement_timeout = statement_timeout;
  }
  if (query_timeout !== undefined) {
    tmp.query_timeout = query_timeout;
  }
  if (application_name !== undefined) {
    tmp.application_name = application_name;
  }
  if (connectionTimeoutMillis !== undefined) {
    tmp.connectionTimeoutMillis = connectionTimeoutMillis;
  }
  if (idle_in_transaction_session_timeout !== undefined) {
    tmp.idle_in_transaction_session_timeout = idle_in_transaction_session_timeout;
  }
  return new (Pg.default.Pool)(tmp);
}

var PgClient = {
  make: make,
  Params: Params,
  getFirst: getFirst,
  getUnique: getUnique,
  PgNotFound: PgNotFound,
  getUniqueExn: getUniqueExn,
  getFirstValueExn: getFirstValueExn,
  getFirstValue: getFirstValue,
  Res: Res,
  Callback: undefined
};

function make$1(user, password, host, database, port, connectionString, ssl, types, statement_timeout, query_timeout, application_name, connectionTimeoutMillis, idle_in_transaction_session_timeout, idleTimeoutMillis, max, allowExitOnIdle, param) {
  var tmp = {};
  if (user !== undefined) {
    tmp.user = user;
  }
  if (password !== undefined) {
    tmp.password = password;
  }
  if (host !== undefined) {
    tmp.host = host;
  }
  if (database !== undefined) {
    tmp.database = database;
  }
  if (port !== undefined) {
    tmp.port = port;
  }
  if (connectionString !== undefined) {
    tmp.connectionString = connectionString;
  }
  if (ssl !== undefined) {
    tmp.ssl = Caml_option.valFromOption(ssl);
  }
  if (types !== undefined) {
    tmp.types = Caml_option.valFromOption(types);
  }
  if (statement_timeout !== undefined) {
    tmp.statement_timeout = statement_timeout;
  }
  if (query_timeout !== undefined) {
    tmp.query_timeout = query_timeout;
  }
  if (application_name !== undefined) {
    tmp.application_name = application_name;
  }
  if (connectionTimeoutMillis !== undefined) {
    tmp.connectionTimeoutMillis = connectionTimeoutMillis;
  }
  if (idle_in_transaction_session_timeout !== undefined) {
    tmp.idle_in_transaction_session_timeout = idle_in_transaction_session_timeout;
  }
  if (idleTimeoutMillis !== undefined) {
    tmp.idleTimeoutMillis = idleTimeoutMillis;
  }
  if (max !== undefined) {
    tmp.max = max;
  }
  if (allowExitOnIdle !== undefined) {
    tmp.allowExitOnIdle = allowExitOnIdle;
  }
  return new (Pg.default.Pool)(tmp);
}

function connect(pgPool, cb) {
  pgPool.connect(function (error, client, release) {
        if (error !== undefined) {
          release();
          return cb({
                      TAG: "Error",
                      _0: error
                    }, release);
        }
        if (client !== undefined) {
          return cb({
                      TAG: "Ok",
                      _0: Caml_option.valFromOption(client)
                    }, release);
        }
        release();
        var error$1 = new TypeError("Invalid callback in nodePg Pool.connect");
        cb({
              TAG: "Error",
              _0: error$1
            }, release);
      });
}

var Callback = {
  query: query,
  connect: connect
};

function connect$1(pgPool, withPgClient) {
  return $$catch(pgPool.connect().then(function (pgClient) {
                    return {
                            TAG: "Ok",
                            _0: pgClient
                          };
                  })).then(function (result) {
              if (result.TAG !== "Ok") {
                return Promise.reject(result._0);
              }
              var pgClient = result._0;
              return $$catch(withPgClient(pgClient).then(function (x) {
                                return {
                                        TAG: "Ok",
                                        _0: x
                                      };
                              })).then(function (result) {
                          return $$catch(pgClient.end().then(function () {
                                          return result;
                                        }));
                        });
            });
}

var PgPool = {
  Params: Params,
  getFirst: getFirst,
  getUnique: getUnique,
  PgNotFound: PgNotFound,
  getUniqueExn: getUniqueExn,
  getFirstValueExn: getFirstValueExn,
  getFirstValue: getFirstValue,
  Res: Res,
  make: make$1,
  Callback: Callback,
  connect: connect$1
};

exports.Uuid = Uuid;
exports.Spacetime = Spacetime;
exports.GraphileLogger = GraphileLogger;
exports.PgResult = PgResult;
exports.PgError = PgError;
exports.QueryCallback = QueryCallback;
exports.Query = Query;
exports.TypeOverrides = TypeOverrides;
exports.PgClient = PgClient;
exports.PgPool = PgPool;
/* pg Not a pure module */
